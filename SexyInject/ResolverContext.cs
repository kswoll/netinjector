using System;
using System.Linq.Expressions;

namespace SexyInject
{
    public class ResolverContext
    {
        public Registry Registry { get; }
        public Binder Binder { get; }
        public IResolver Resolver { get; private set; }

        public ResolverContext(Registry registry, Binder binder, IResolver resolver)
        {
            Registry = registry;
            Binder = binder;
            Resolver = resolver;
        }

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext When(Func<ResolveContext, Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, predicate));

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext When(Func<Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, (context, type) => predicate(type)));

        /// <summary>
        /// Cache values returned by the resolver based on the key generated by the specified keyGenerator.
        /// </summary>
        /// <param name="keySelector">The result of this selector will be used as the key in the dictionary cache.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext Cache(Func<ResolveContext, Type, object> keySelector) => Decorate(x => new CacheResolver(x, keySelector));

        public ResolverContext Inject(Func<ResolveContext, Type, object> factory) => Decorate(x => new ClassInjectionResolver(x, factory));

        protected ResolverContext Decorate(Func<IResolver, IResolver> decorator)
        {
            Resolver = decorator(Resolver);
            return this;
        }
    }

    public class ResolverContext<T> : ResolverContext
    {
        public new Binder<T> Binder => (Binder<T>)base.Binder;

        public ResolverContext(Registry registry, Binder<T> binder, IResolver resolver) : base(registry, binder, resolver)
        {
        }

        public ResolverContext<T> Inject<TValue>(Expression<Func<T, TValue>> property, Func<ResolveContext, Type, object> factory)
        {
            return Decorate(x => new PropertyInjectionResolver(x, property, factory));
        }

        protected new ResolverContext<T> Decorate(Func<IResolver, IResolver> decorator)
        {
            return (ResolverContext<T>)base.Decorate(decorator);
        }
    }
}