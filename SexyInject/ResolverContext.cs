using System;
using System.Linq.Expressions;

namespace SexyInject
{
    /// <summary>
    /// Helper class to facilitate a fluent syntax for customizing the binding between a specified pair of types.
    /// </summary>
    public class ResolverContext
    {
        public Registry Registry { get; }
        public Binder Binder { get; }
        public IResolver Resolver { get; private set; }

        public ResolverContext(Registry registry, Binder binder, IResolver resolver)
        {
            Registry = registry;
            Binder = binder;
            Resolver = resolver;
        }

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext When(Func<ResolveContext, Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, predicate));

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext When(Func<Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, (context, type) => predicate(type)));

        /// <summary>
        /// Cache values returned by the resolver based on the key generated by the specified keyGenerator.
        /// </summary>
        /// <param name="keySelector">The result of this selector will be used as the key in the dictionary cache.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext Cache(Func<ResolveContext, Type, object> keySelector) => Decorate(x => new CacheResolver(x, keySelector));

        /// <summary>
        /// For the current binding only, uses the instance provided by the specified factory to resolve any dependencies.
        /// </summary>
        /// <param name="factory">Provides an instance of the dependency to inject</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext InjectArgument(Func<ResolveContext, Type, object> factory) => Decorate(x => new ClassInjectionResolver(x, factory));

        /// <summary>
        /// For the current binding only, uses the instance provided by the specified factory to resolve any dependencies.
        /// </summary>
        /// <param name="factory">Provides an instance of the dependency to inject</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext InjectArgument(Func<Type, object> factory) => Decorate(x => new ClassInjectionResolver(x, (context, type) => factory(type)));

        protected ResolverContext Decorate(Func<IResolver, IResolver> decorator)
        {
            Resolver = decorator(Resolver);
            return this;
        }
    }

    /// <summary>
    /// Helper class to facilitate a fluent syntax for customizing the binding between a specified pair of types.
    /// </summary>
    /// <typeparam name="T">The type to which the binding will resolve.</typeparam>
    public class ResolverContext<T> : ResolverContext
    {
        public new Binder<T> Binder => (Binder<T>)base.Binder;

        public ResolverContext(Registry registry, Binder<T> binder, IResolver resolver) : base(registry, binder, resolver)
        {
        }

        /// <summary>
        /// For the current binding only, uses the instance provided by the specified factory to resolve any dependencies.
        /// </summary>
        /// <typeparam name="TValue">The type of object that is the dependency being injected</typeparam>
        /// <param name="property">The property to which the dependency will be injected.</param>
        /// <param name="factory">Provides the dependency that should be injected into the specified property.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext<T> InjectProperty<TValue>(Expression<Func<T, TValue>> property, Func<ResolveContext, Type, TValue> factory)
        {
            return Decorate(x => new PropertyInjectionResolver(x, property, (context, type) => factory(context, type)));
        }

        /// <summary>
        /// For the current binding only, uses the instance provided by the specified factory to resolve any dependencies.
        /// </summary>
        /// <typeparam name="TValue">The type of object that is the dependency being injected</typeparam>
        /// <param name="property">The property to which the dependency will be injected.</param>
        /// <param name="factory">Provides the dependency that should be injected into the specified property.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext<T> InjectProperty<TValue>(Expression<Func<T, TValue>> property, Func<ResolveContext, TValue> factory)
        {
            return Decorate(x => new PropertyInjectionResolver(x, property, (context, type) => factory(context)));
        }

        /// <summary>
        /// Makes it so the specified property will be injected with an instance of its type.
        /// </summary>
        /// <typeparam name="TValue">The type of object that is the dependency being injected</typeparam>
        /// <param name="property">The property to which the dependency will be injected.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext<T> InjectProperty<TValue>(Expression<Func<T, TValue>> property)
        {
            return Decorate(x => new PropertyInjectionResolver(x, property, (context, type) => context.Resolve(type)));
        }

        /// <summary>
        /// Exactly the same as calling the InjectProperty overload that only accepts a property expression, 
        /// but for each property you provide in the properties array.
        /// </summary>
        /// <param name="properties">The array of properties that should be injected with dependencies.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public ResolverContext<T> InjectProperties(params Expression<Func<T, object>>[] properties)
        {
            foreach (var property in properties)
                InjectProperty(property);
            return this;
        }

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public new ResolverContext<T> When(Func<ResolveContext, Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, predicate));

        /// <summary>
        /// Constrains the resolver to only be applied when the specified predicate is satisfied.
        /// </summary>
        /// <param name="predicate">When this predicate returns true for a given resolution request, the resolver will be used.</param>
        /// <returns>This context to facilitate fluent syntax</returns>
        public new ResolverContext<T> When(Func<Type, bool> predicate) => Decorate(x => new PredicatedResolver(x, (context, type) => predicate(type)));

        protected new ResolverContext<T> Decorate(Func<IResolver, IResolver> decorator)
        {
            return (ResolverContext<T>)base.Decorate(decorator);
        }
    }
}